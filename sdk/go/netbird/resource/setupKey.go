// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package resource

import (
	"context"
	"reflect"

	"errors"
	"github.com/mbrav/pulumi-netbird/sdk/go/netbird/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a NetBird setup key.
type SetupKey struct {
	pulumi.CustomResourceState

	// Allow peers to add extra DNS labels beyond the base peer name.
	AllowExtraDnsLabels pulumi.BoolPtrOutput `pulumi:"allowExtraDnsLabels"`
	// Group IDs to auto-assign to peers created with this key.
	AutoGroups pulumi.StringArrayOutput `pulumi:"autoGroups"`
	// Whether peers registered with this key are ephemeral (auto-expire).
	Ephemeral pulumi.BoolPtrOutput   `pulumi:"ephemeral"`
	Expires   pulumi.StringPtrOutput `pulumi:"expires"`
	// Time-to-live in seconds from creation; use 0 for no expiration if supported by the API.
	ExpiresIn pulumi.IntOutput       `pulumi:"expiresIn"`
	Key       pulumi.StringPtrOutput `pulumi:"key"`
	LastUsed  pulumi.StringPtrOutput `pulumi:"lastUsed"`
	// Setup key display name.
	Name    pulumi.StringOutput    `pulumi:"name"`
	Revoked pulumi.BoolPtrOutput   `pulumi:"revoked"`
	State   pulumi.StringPtrOutput `pulumi:"state"`
	// Setup key type: 'one-off' (single use) or 'reusable'.
	Type      SetupKeyTypeOutput     `pulumi:"type"`
	UpdatedAt pulumi.StringPtrOutput `pulumi:"updatedAt"`
	// Maximum uses for reusable keys; 0 = unlimited.
	UsageLimit pulumi.IntOutput     `pulumi:"usageLimit"`
	UsedTimes  pulumi.IntPtrOutput  `pulumi:"usedTimes"`
	Valid      pulumi.BoolPtrOutput `pulumi:"valid"`
}

// NewSetupKey registers a new resource with the given unique name, arguments, and options.
func NewSetupKey(ctx *pulumi.Context,
	name string, args *SetupKeyArgs, opts ...pulumi.ResourceOption) (*SetupKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AutoGroups == nil {
		return nil, errors.New("invalid value for required argument 'AutoGroups'")
	}
	if args.ExpiresIn == nil {
		return nil, errors.New("invalid value for required argument 'ExpiresIn'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	if args.UsageLimit == nil {
		return nil, errors.New("invalid value for required argument 'UsageLimit'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SetupKey
	err := ctx.RegisterResource("netbird:resource:SetupKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSetupKey gets an existing SetupKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSetupKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SetupKeyState, opts ...pulumi.ResourceOption) (*SetupKey, error) {
	var resource SetupKey
	err := ctx.ReadResource("netbird:resource:SetupKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SetupKey resources.
type setupKeyState struct {
}

type SetupKeyState struct {
}

func (SetupKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*setupKeyState)(nil)).Elem()
}

type setupKeyArgs struct {
	// Allow peers to add extra DNS labels beyond the base peer name.
	AllowExtraDnsLabels *bool `pulumi:"allowExtraDnsLabels"`
	// Group IDs to auto-assign to peers created with this key.
	AutoGroups []string `pulumi:"autoGroups"`
	// Whether peers registered with this key are ephemeral (auto-expire).
	Ephemeral *bool `pulumi:"ephemeral"`
	// Time-to-live in seconds from creation; use 0 for no expiration if supported by the API.
	ExpiresIn int `pulumi:"expiresIn"`
	// Setup key display name.
	Name string `pulumi:"name"`
	// Setup key type: 'one-off' (single use) or 'reusable'.
	Type SetupKeyType `pulumi:"type"`
	// Maximum uses for reusable keys; 0 = unlimited.
	UsageLimit int `pulumi:"usageLimit"`
}

// The set of arguments for constructing a SetupKey resource.
type SetupKeyArgs struct {
	// Allow peers to add extra DNS labels beyond the base peer name.
	AllowExtraDnsLabels pulumi.BoolPtrInput
	// Group IDs to auto-assign to peers created with this key.
	AutoGroups pulumi.StringArrayInput
	// Whether peers registered with this key are ephemeral (auto-expire).
	Ephemeral pulumi.BoolPtrInput
	// Time-to-live in seconds from creation; use 0 for no expiration if supported by the API.
	ExpiresIn pulumi.IntInput
	// Setup key display name.
	Name pulumi.StringInput
	// Setup key type: 'one-off' (single use) or 'reusable'.
	Type SetupKeyTypeInput
	// Maximum uses for reusable keys; 0 = unlimited.
	UsageLimit pulumi.IntInput
}

func (SetupKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*setupKeyArgs)(nil)).Elem()
}

type SetupKeyInput interface {
	pulumi.Input

	ToSetupKeyOutput() SetupKeyOutput
	ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput
}

func (*SetupKey) ElementType() reflect.Type {
	return reflect.TypeOf((**SetupKey)(nil)).Elem()
}

func (i *SetupKey) ToSetupKeyOutput() SetupKeyOutput {
	return i.ToSetupKeyOutputWithContext(context.Background())
}

func (i *SetupKey) ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyOutput)
}

// SetupKeyArrayInput is an input type that accepts SetupKeyArray and SetupKeyArrayOutput values.
// You can construct a concrete instance of `SetupKeyArrayInput` via:
//
//	SetupKeyArray{ SetupKeyArgs{...} }
type SetupKeyArrayInput interface {
	pulumi.Input

	ToSetupKeyArrayOutput() SetupKeyArrayOutput
	ToSetupKeyArrayOutputWithContext(context.Context) SetupKeyArrayOutput
}

type SetupKeyArray []SetupKeyInput

func (SetupKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SetupKey)(nil)).Elem()
}

func (i SetupKeyArray) ToSetupKeyArrayOutput() SetupKeyArrayOutput {
	return i.ToSetupKeyArrayOutputWithContext(context.Background())
}

func (i SetupKeyArray) ToSetupKeyArrayOutputWithContext(ctx context.Context) SetupKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyArrayOutput)
}

// SetupKeyMapInput is an input type that accepts SetupKeyMap and SetupKeyMapOutput values.
// You can construct a concrete instance of `SetupKeyMapInput` via:
//
//	SetupKeyMap{ "key": SetupKeyArgs{...} }
type SetupKeyMapInput interface {
	pulumi.Input

	ToSetupKeyMapOutput() SetupKeyMapOutput
	ToSetupKeyMapOutputWithContext(context.Context) SetupKeyMapOutput
}

type SetupKeyMap map[string]SetupKeyInput

func (SetupKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SetupKey)(nil)).Elem()
}

func (i SetupKeyMap) ToSetupKeyMapOutput() SetupKeyMapOutput {
	return i.ToSetupKeyMapOutputWithContext(context.Background())
}

func (i SetupKeyMap) ToSetupKeyMapOutputWithContext(ctx context.Context) SetupKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SetupKeyMapOutput)
}

type SetupKeyOutput struct{ *pulumi.OutputState }

func (SetupKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SetupKey)(nil)).Elem()
}

func (o SetupKeyOutput) ToSetupKeyOutput() SetupKeyOutput {
	return o
}

func (o SetupKeyOutput) ToSetupKeyOutputWithContext(ctx context.Context) SetupKeyOutput {
	return o
}

// Allow peers to add extra DNS labels beyond the base peer name.
func (o SetupKeyOutput) AllowExtraDnsLabels() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolPtrOutput { return v.AllowExtraDnsLabels }).(pulumi.BoolPtrOutput)
}

// Group IDs to auto-assign to peers created with this key.
func (o SetupKeyOutput) AutoGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringArrayOutput { return v.AutoGroups }).(pulumi.StringArrayOutput)
}

// Whether peers registered with this key are ephemeral (auto-expire).
func (o SetupKeyOutput) Ephemeral() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolPtrOutput { return v.Ephemeral }).(pulumi.BoolPtrOutput)
}

func (o SetupKeyOutput) Expires() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringPtrOutput { return v.Expires }).(pulumi.StringPtrOutput)
}

// Time-to-live in seconds from creation; use 0 for no expiration if supported by the API.
func (o SetupKeyOutput) ExpiresIn() pulumi.IntOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntOutput { return v.ExpiresIn }).(pulumi.IntOutput)
}

func (o SetupKeyOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringPtrOutput { return v.Key }).(pulumi.StringPtrOutput)
}

func (o SetupKeyOutput) LastUsed() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringPtrOutput { return v.LastUsed }).(pulumi.StringPtrOutput)
}

// Setup key display name.
func (o SetupKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o SetupKeyOutput) Revoked() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolPtrOutput { return v.Revoked }).(pulumi.BoolPtrOutput)
}

func (o SetupKeyOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// Setup key type: 'one-off' (single use) or 'reusable'.
func (o SetupKeyOutput) Type() SetupKeyTypeOutput {
	return o.ApplyT(func(v *SetupKey) SetupKeyTypeOutput { return v.Type }).(SetupKeyTypeOutput)
}

func (o SetupKeyOutput) UpdatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.StringPtrOutput { return v.UpdatedAt }).(pulumi.StringPtrOutput)
}

// Maximum uses for reusable keys; 0 = unlimited.
func (o SetupKeyOutput) UsageLimit() pulumi.IntOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntOutput { return v.UsageLimit }).(pulumi.IntOutput)
}

func (o SetupKeyOutput) UsedTimes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.IntPtrOutput { return v.UsedTimes }).(pulumi.IntPtrOutput)
}

func (o SetupKeyOutput) Valid() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SetupKey) pulumi.BoolPtrOutput { return v.Valid }).(pulumi.BoolPtrOutput)
}

type SetupKeyArrayOutput struct{ *pulumi.OutputState }

func (SetupKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SetupKey)(nil)).Elem()
}

func (o SetupKeyArrayOutput) ToSetupKeyArrayOutput() SetupKeyArrayOutput {
	return o
}

func (o SetupKeyArrayOutput) ToSetupKeyArrayOutputWithContext(ctx context.Context) SetupKeyArrayOutput {
	return o
}

func (o SetupKeyArrayOutput) Index(i pulumi.IntInput) SetupKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SetupKey {
		return vs[0].([]*SetupKey)[vs[1].(int)]
	}).(SetupKeyOutput)
}

type SetupKeyMapOutput struct{ *pulumi.OutputState }

func (SetupKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SetupKey)(nil)).Elem()
}

func (o SetupKeyMapOutput) ToSetupKeyMapOutput() SetupKeyMapOutput {
	return o
}

func (o SetupKeyMapOutput) ToSetupKeyMapOutputWithContext(ctx context.Context) SetupKeyMapOutput {
	return o
}

func (o SetupKeyMapOutput) MapIndex(k pulumi.StringInput) SetupKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SetupKey {
		return vs[0].(map[string]*SetupKey)[vs[1].(string)]
	}).(SetupKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyInput)(nil)).Elem(), &SetupKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyArrayInput)(nil)).Elem(), SetupKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SetupKeyMapInput)(nil)).Elem(), SetupKeyMap{})
	pulumi.RegisterOutputType(SetupKeyOutput{})
	pulumi.RegisterOutputType(SetupKeyArrayOutput{})
	pulumi.RegisterOutputType(SetupKeyMapOutput{})
}
