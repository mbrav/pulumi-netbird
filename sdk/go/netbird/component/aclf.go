// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package component

import (
	"context"
	"reflect"

	"errors"
	"github.com/mbrav/pulumi-netbird/sdk/go/netbird/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ACLF struct {
	pulumi.ResourceState

	Description     pulumi.StringOutput `pulumi:"description"`
	DestRuleTotal   pulumi.IntOutput    `pulumi:"destRuleTotal"`
	Json_path       pulumi.StringOutput `pulumi:"json_path"`
	Name            pulumi.StringOutput `pulumi:"name"`
	SourceRuleCount pulumi.IntOutput    `pulumi:"sourceRuleCount"`
}

// NewACLF registers a new resource with the given unique name, arguments, and options.
func NewACLF(ctx *pulumi.Context,
	name string, args *ACLFArgs, opts ...pulumi.ResourceOption) (*ACLF, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Description == nil {
		return nil, errors.New("invalid value for required argument 'Description'")
	}
	if args.Json_path == nil {
		return nil, errors.New("invalid value for required argument 'Json_path'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ACLF
	err := ctx.RegisterRemoteComponentResource("netbird:component:ACLF", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type aclfArgs struct {
	Description string `pulumi:"description"`
	Json_path   string `pulumi:"json_path"`
	Name        string `pulumi:"name"`
}

// The set of arguments for constructing a ACLF resource.
type ACLFArgs struct {
	Description pulumi.StringInput
	Json_path   pulumi.StringInput
	Name        pulumi.StringInput
}

func (ACLFArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aclfArgs)(nil)).Elem()
}

type ACLFInput interface {
	pulumi.Input

	ToACLFOutput() ACLFOutput
	ToACLFOutputWithContext(ctx context.Context) ACLFOutput
}

func (*ACLF) ElementType() reflect.Type {
	return reflect.TypeOf((**ACLF)(nil)).Elem()
}

func (i *ACLF) ToACLFOutput() ACLFOutput {
	return i.ToACLFOutputWithContext(context.Background())
}

func (i *ACLF) ToACLFOutputWithContext(ctx context.Context) ACLFOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ACLFOutput)
}

// ACLFArrayInput is an input type that accepts ACLFArray and ACLFArrayOutput values.
// You can construct a concrete instance of `ACLFArrayInput` via:
//
//	ACLFArray{ ACLFArgs{...} }
type ACLFArrayInput interface {
	pulumi.Input

	ToACLFArrayOutput() ACLFArrayOutput
	ToACLFArrayOutputWithContext(context.Context) ACLFArrayOutput
}

type ACLFArray []ACLFInput

func (ACLFArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ACLF)(nil)).Elem()
}

func (i ACLFArray) ToACLFArrayOutput() ACLFArrayOutput {
	return i.ToACLFArrayOutputWithContext(context.Background())
}

func (i ACLFArray) ToACLFArrayOutputWithContext(ctx context.Context) ACLFArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ACLFArrayOutput)
}

// ACLFMapInput is an input type that accepts ACLFMap and ACLFMapOutput values.
// You can construct a concrete instance of `ACLFMapInput` via:
//
//	ACLFMap{ "key": ACLFArgs{...} }
type ACLFMapInput interface {
	pulumi.Input

	ToACLFMapOutput() ACLFMapOutput
	ToACLFMapOutputWithContext(context.Context) ACLFMapOutput
}

type ACLFMap map[string]ACLFInput

func (ACLFMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ACLF)(nil)).Elem()
}

func (i ACLFMap) ToACLFMapOutput() ACLFMapOutput {
	return i.ToACLFMapOutputWithContext(context.Background())
}

func (i ACLFMap) ToACLFMapOutputWithContext(ctx context.Context) ACLFMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ACLFMapOutput)
}

type ACLFOutput struct{ *pulumi.OutputState }

func (ACLFOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ACLF)(nil)).Elem()
}

func (o ACLFOutput) ToACLFOutput() ACLFOutput {
	return o
}

func (o ACLFOutput) ToACLFOutputWithContext(ctx context.Context) ACLFOutput {
	return o
}

func (o ACLFOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *ACLF) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

func (o ACLFOutput) DestRuleTotal() pulumi.IntOutput {
	return o.ApplyT(func(v *ACLF) pulumi.IntOutput { return v.DestRuleTotal }).(pulumi.IntOutput)
}

func (o ACLFOutput) Json_path() pulumi.StringOutput {
	return o.ApplyT(func(v *ACLF) pulumi.StringOutput { return v.Json_path }).(pulumi.StringOutput)
}

func (o ACLFOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ACLF) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ACLFOutput) SourceRuleCount() pulumi.IntOutput {
	return o.ApplyT(func(v *ACLF) pulumi.IntOutput { return v.SourceRuleCount }).(pulumi.IntOutput)
}

type ACLFArrayOutput struct{ *pulumi.OutputState }

func (ACLFArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ACLF)(nil)).Elem()
}

func (o ACLFArrayOutput) ToACLFArrayOutput() ACLFArrayOutput {
	return o
}

func (o ACLFArrayOutput) ToACLFArrayOutputWithContext(ctx context.Context) ACLFArrayOutput {
	return o
}

func (o ACLFArrayOutput) Index(i pulumi.IntInput) ACLFOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ACLF {
		return vs[0].([]*ACLF)[vs[1].(int)]
	}).(ACLFOutput)
}

type ACLFMapOutput struct{ *pulumi.OutputState }

func (ACLFMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ACLF)(nil)).Elem()
}

func (o ACLFMapOutput) ToACLFMapOutput() ACLFMapOutput {
	return o
}

func (o ACLFMapOutput) ToACLFMapOutputWithContext(ctx context.Context) ACLFMapOutput {
	return o
}

func (o ACLFMapOutput) MapIndex(k pulumi.StringInput) ACLFOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ACLF {
		return vs[0].(map[string]*ACLF)[vs[1].(string)]
	}).(ACLFOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ACLFInput)(nil)).Elem(), &ACLF{})
	pulumi.RegisterInputType(reflect.TypeOf((*ACLFArrayInput)(nil)).Elem(), ACLFArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ACLFMapInput)(nil)).Elem(), ACLFMap{})
	pulumi.RegisterOutputType(ACLFOutput{})
	pulumi.RegisterOutputType(ACLFArrayOutput{})
	pulumi.RegisterOutputType(ACLFMapOutput{})
}
